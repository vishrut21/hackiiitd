#/* $begin revcopy-ys */
##################################################################
# revcopy.ys
#
# Copy a src block of len words to dst in reverse order.
# Return the number of positive words (>0) contained in src.
#
# TODO: Include your name and ID here.
# Olavi Äikäs - olavi.aikas
# Describe how and why you modified the baseline code.
#
# 1. The first thing to do was to get rid of the Init block
# which used a loop to multiply len by 8. However since 8
# is conveniently a power of two, we can just add r11 to itself
# 3 times and achieve the same effect, eliminating the need for
# a loop, which eliminates counters and thus saves operations.
#
# 2. Next up I unrolled the loop by making a bigger loop that
# copies 8 words/cycle. This way length only has to be updated
# once per 8 words which cuts operations. I also realised that
# since we check before the big loop that there are at least 8
# words to be copied, we can access the memory with constant
# shifts, and so we can defer updating %rdi and %rsi to the end
# of the loop as well.
#
# 3. I experimented with some ways to optimise the tail (e.g last
# 1-7 words) and ended up with this cascade design where len
# is updated after every copy to see if it was the last, but
# src and dst are never updated since we know there are at most
# 7 blocks of memory left. The name cascade originally came from
# my idea that it would be nice to check how many blocks remain
# and transfer them in one go, but that led to 7 cases which exceeded
# the limit for the length of the program.
#
# 4. I also added the iaddq instruction to pipe-full.hcl in order
# to cut down on having to store some constants in registers to
# perform increments.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
	# Loop header
	xorq %rax, %rax		# count = 0;
	andq %rdx, %rdx		# len <= 0?
	jle Done		# if so, goto Done:

 	rrmovq %rdx, %r11       # r11 = len
	addq %r11, %r11		# multiply r11 by 8
	addq %r11, %r11
	addq %r11, %r11
	addq %r11, %rsi
	rrmovq %rdx, %r11
	iaddq $-8, %r11
	jl Csc			#Csc for cascade

Gloop:	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, -8(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos1		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos1:	mrmovq 8(%rdi), %r8	# read val from src...
	rmmovq %r8, -16(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos2		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos2:	mrmovq 16(%rdi), %r8	# read val from src...
	rmmovq %r8, -24(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos3		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos3:	mrmovq 24(%rdi), %r8	# read val from src...
	rmmovq %r8, -32(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos4		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos4:	mrmovq 32(%rdi), %r8	# read val from src...
	rmmovq %r8, -40(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos5		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos5:	mrmovq 40(%rdi), %r8	# read val from src...
	rmmovq %r8, -48(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos6		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos6:	mrmovq 48(%rdi), %r8	# read val from src...
	rmmovq %r8, -56(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos7		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos7:	mrmovq 56(%rdi), %r8	# read val from src...
	rmmovq %r8, -64(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos8		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos8:	iaddq $64, %rdi		# src++
	iaddq $-64, %rsi
	iaddq $-8, %rdx		# len - 8
	iaddq $-8, %r11
	jge Gloop

	andq %rdx, %rdx
	je Done

Csc:	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, -8(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Csc1		# if so, goto Npos:
	iaddq $1, %rax		# count++
Csc1:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 8(%rdi), %r8	# read val from src...
	rmmovq %r8, -16(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Csc2		# if so, goto Npos:
	iaddq $1, %rax		# count++
Csc2:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 16(%rdi), %r8	# read val from src...
	rmmovq %r8, -24(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Csc3		# if so, goto Npos:
	iaddq $1, %rax		# count++
Csc3:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 24(%rdi), %r8	# read val from src...
	rmmovq %r8, -32(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Csc4		# if so, goto Npos:
	iaddq $1, %rax		# count++
Csc4:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 32(%rdi), %r8	# read val from src...
	rmmovq %r8, -40(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Csc5		# if so, goto Npos:
	iaddq $1, %rax		# count++
Csc5:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 40(%rdi), %r8	# read val from src...
	rmmovq %r8, -48(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Csc6		# if so, goto Npos:
	iaddq $1, %rax		# count++
Csc6:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 48(%rdi), %r8	# read val from src...
	rmmovq %r8, -56(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Done		# if so, goto Npos:
	iaddq $1, %rax		# count++

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end revcopy-ys */
