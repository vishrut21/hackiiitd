#/* $begin revcopy-ys */
##################################################################
# revcopy.ys
#
# Copy a src block of len words to dst in reverse order.
# Return the number of positive words (>0) contained in src.
#
# TODO: Include your name and ID here.
# Vishrut Malik, vishrut.malik
#
# Describe how and why you modified the baseline code.
#
# Firstly we eliminate the init loop which essentially multiplies len by 8. 
# Since it is an elementary operation, we simply add r11 3 times to achieve it.
# As a result we eliminate the need for a loop, ridding operations and
# counters.
#
# Secondly we can notice that before running the loop we check if at least 8 
# words are required to be copied, so we get the idea of accessing memory with 
# constant shifts and thus updating %rsi and %rdi to the end of the loop, as 
# well as we can modify the loop to copy 8 words each time.
#
# Next, we now have to deal with the last 1-7 words. So we make 6 more labels 
# to copy and check with len if we reached the end of the array.
#
# Last but not the least, pipe-full.hcl is editted to add IADDQ at 
# necessary areas to further optimize the immediate storage.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
	# Loop header
	xorq %rax, %rax		# count = 0;
	andq %rdx, %rdx		# len <= 0?
	jle Done		# if so, goto Done:

 	rrmovq %rdx, %r11       # r11 = len
	addq %r11, %r11		# we multiply r11 by 8
	addq %r11, %r11
	addq %r11, %r11
	addq %r11, %rsi
	rrmovq %rdx, %r11
	iaddq $-8, %r11
	jl label			#label as mentioned in desc

Loop:	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, -8(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos1		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos1:	mrmovq 8(%rdi), %r8	# read val from src...
	rmmovq %r8, -16(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos2		# if so, goto Npos2:
	iaddq $1, %rax		# count++
Npos2:	mrmovq 16(%rdi), %r8	# read val from src...
	rmmovq %r8, -24(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos3		# if so, goto Npos3:
	iaddq $1, %rax		# count++
Npos3:	mrmovq 24(%rdi), %r8	# read val from src...
	rmmovq %r8, -32(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos4		# if so, goto Npos4:
	iaddq $1, %rax		# count++
Npos4:	mrmovq 32(%rdi), %r8	# read val from src...
	rmmovq %r8, -40(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos5		# if so, goto Npos5:
	iaddq $1, %rax		# count++
Npos5:	mrmovq 40(%rdi), %r8	# read val from src...
	rmmovq %r8, -48(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos6		# if so, goto Npos6:
	iaddq $1, %rax		# count++
Npos6:	mrmovq 48(%rdi), %r8	# read val from src...
	rmmovq %r8, -56(%rsi)	# copy it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos7		# if so, goto Npos7:
	iaddq $1, %rax		# count++
Npos7:	mrmovq 56(%rdi), %r8	# read val from src...
	rmmovq %r8, -64(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Npos8		# if so, goto Npos8:
	iaddq $1, %rax		# count++
Npos8:	iaddq $64, %rdi		# src end
	iaddq $-64, %rsi	# dst end
	iaddq $-8, %rdx		# len-8
	iaddq $-8, %r11
	jge Loop

	andq %rdx, %rdx
	je Done

label:	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, -8(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle label1		# if so, goto label1:
	iaddq $1, %rax		# count++
label1:	iaddq $-1, %rdx		# len--
	jle Done
	mrmovq 8(%rdi), %r8	# read val from src...
	rmmovq %r8, -16(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle label2		# if so, goto label2:
	iaddq $1, %rax		# count++
label2:	iaddq $-1, %rdx		# len-1
	jle Done
	mrmovq 16(%rdi), %r8	# read val from src...
	rmmovq %r8, -24(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle label3		# if so, goto label3:
	iaddq $1, %rax		# count++
label3:	iaddq $-1, %rdx		# len-1
	jle Done
	mrmovq 24(%rdi), %r8	# read val from src...
	rmmovq %r8, -32(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle label4		# if so, goto label4:
	iaddq $1, %rax		# count++
label4:	iaddq $-1, %rdx		# len-1
	jle Done
	mrmovq 32(%rdi), %r8	# read val from src...
	rmmovq %r8, -40(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle label5		# if so, goto label5:
	iaddq $1, %rax		# count++
label5:	iaddq $-1, %rdx		# len-1
	jle Done
	mrmovq 40(%rdi), %r8	# read val from src...
	rmmovq %r8, -48(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle label6		# if so, goto label6:
	iaddq $1, %rax		# count++
label6:	iaddq $-1, %rdx		# len-1
	jle Done
	mrmovq 48(%rdi), %r8	# read val from src...
	rmmovq %r8, -56(%rsi)	# store it to dst...
	andq %r8, %r8		# val <= 0?
	jle Done		# if so, goto Done:
	iaddq $1, %rax		# count++

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end revcopy-ys */

